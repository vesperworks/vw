package vw.effect.fire {	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.BlendMode;	import flash.display.DisplayObject;	import flash.display.Sprite;	import flash.events.Event;	import flash.filters.BlurFilter;	import flash.filters.ColorMatrixFilter;	import flash.filters.DisplacementMapFilter;	import flash.filters.DisplacementMapFilterMode;	import flash.geom.ColorTransform;	import flash.geom.Matrix;	import flash.geom.Point;	public class Fire extends Sprite {		private var src:*;		private var _canvas:Bitmap;		private var mainBmd:BitmapData;		private var tmpBmd:BitmapData;		private var perlinBmd:BitmapData;		private var _matrix:Matrix;		private var _Pt:Point;		private var _ctf:ColorTransform;		private var _cmf:ColorMatrixFilter;		private var _dmf:DisplacementMapFilter;		private var _blur:BlurFilter;		private var _target:DisplayObject;		private var originalW:Number;		private var originalH:Number;		private var _config:FireConfig;
		public function get bitmapData():BitmapData {			return this._canvas.bitmapData;		}		public function get config():FireConfig {			return _config;		}		public function Fire( _src:DisplayObject = null,fireConfig:FireConfig = null) {			if ( !_src ) {				src = new Sprite();				src.graphics.beginFill(0xFFFFFF, 1);				src.graphics.drawEllipse(0, 0, 10, 10);				src.graphics.endFill();			} else {				src = _src;			}						_config = fireConfig ? fireConfig : new FireConfig();			_canvas = new Bitmap();			_target = src;			_matrix = new Matrix();			_Pt = new Point();						addChild(_canvas);			init();			start();		}		private function start():void {			addEventListener(Event.ENTER_FRAME, burn);		}		private function init():void {			if ( mainBmd ) {				mainBmd.dispose();				mainBmd = null;				tmpBmd.dispose();				tmpBmd = null;				perlinBmd.dispose();				perlinBmd = null;			}			originalW = _target.width;			originalH = _target.height;			var w:Number = originalW * 6;			trace('w: ' + (w));			var h:Number = originalH * 6;			trace('h: ' + (h));			mainBmd = new BitmapData(w, h, true, 0);			tmpBmd = mainBmd.clone();			perlinBmd = new BitmapData(w * 2, h * 2, false, 0);			_canvas.bitmapData = mainBmd;						_canvas.x = -_canvas.width / 2;			_canvas.y = -_canvas.height / 2;			perlinBmd.perlinNoise(30 * config.SCALE, 20 * config.SCALE, 1, -Math.random() * 1000 | 0, false, true, 1 | 2, false);			perlinBmd.colorTransform(perlinBmd.rect, new ColorTransform(1, 1 - config.AMOUNT * 0.5, 1, 1, 0, 0, 0, 0));			_cmf = new ColorMatrixFilter([0.96 - 0.35 * config.FADE,0.1,0,0,-1,   0,0.9 - 0.45 * config.FADE,0,0,0,   0,0,0.8 - 0.55 * config.FADE,0,0,   0,0.1,0,1,-25 + config.SMOKE * 24]);			_ctf = new ColorTransform(0, 0, 0, 1, 255, 255, 210, 0);			_dmf = new DisplacementMapFilter(perlinBmd, _Pt, 2, 1, 30 * config.DISTORTION_X, 30 * config.DISTORTION_Y, DisplacementMapFilterMode.CLAMP);			_blur = new BlurFilter(32 * config.SPREAD, 32 * config.SPREAD, 2);		}		private function burn( e:Event ):void {			var dM:Matrix = _target.transform.matrix;			dM.tx = originalW * 6 / 2 - originalW / 2;			dM.ty = originalH * 6 / 2 - originalH / 2;			tmpBmd.fillRect(tmpBmd.rect, 0);			_ctf.alphaOffset = -Math.random() * 200 | 0;			tmpBmd.draw(_target, dM, _ctf, BlendMode.ADD);			tmpBmd.applyFilter(tmpBmd, tmpBmd.rect, _Pt, _blur);			mainBmd.draw(tmpBmd, _matrix, null, BlendMode.ADD);			_dmf.mapPoint = new Point(-Math.random() * ( perlinBmd.width - mainBmd.width ) | 0, -Math.random() * ( perlinBmd.height - mainBmd.height ) | 0);			mainBmd.applyFilter(mainBmd, mainBmd.rect, _Pt, _dmf);			mainBmd.applyFilter(mainBmd, mainBmd.rect, _Pt, _cmf);		}	}}